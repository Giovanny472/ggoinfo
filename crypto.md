# Hash, Crypto

## Хеширование и шифрование

**Генератор псевдослучайных чисел** — генерирует случайные байты на основе стартового числа (seed) и математического алгоритма. Зная число seed, можно повторить последовательность следующих байт.

Он не **подходит** для генерации чувствительных данных, например кук, токенов или ключей.

**Криптостойкий генератор случайных чисел** — генерирует байты на основе энтропии, порождаемой аппаратно. Такую случайность нельзя предугадать, поэтому нельзя вывести всю последовательность. Этот генератор реализован на уровне операционной системы.

В Go сгенерировать криптостойкие случайные байты можно функцией **rand.Read** из пакета **crypto/rand**. В параметре нужно передать:
+ слайс байт ненулевой длины, который будет заполнен случайными байтами. 
+ Размер слайса не изменяется. 
  
Чтобы затем использовать полученный массив байт, например для кук(cookies), нужно дополнительно его закодировать. Это можно сделать функцией ***hex.EncodeToString** из пакета **encoding/hex**.

В отличие от генератора псевдослучайных чисел, этот код будет каждый раз при запуске выводить новую последовательность байт.
```Go
package main

import (
    "crypto/rand"
    "encoding/hex"
    "fmt"
)

func main() {
    // определяем слайс нужной длины
    b := make([]byte, 16)
    // записываем байты в массив b
    _, err := rand.Read(b) 
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    fmt.Println(hex.EncodeToString(b))
} 
```

Пример:  Написать функцию, которая будет генерировать массив случайных байт. Размер массива передаётся параметром. Функция должна возвращать массив в виде строки в кодировке base64.

```Go
func RandBytes(n int) (string, error) {
    b := make([]byte, n)
    _, err := rand.Read(b)
    if err != nil {
        return ``, err
    }
    return base64.StdEncoding.EncodeToString(b), nil
} 
```

## Хеширование 

**Хеш-функция** — это функция, которая приводит любую последовательность байт к установленной длине. Длина зависит от используемого алгоритма. Хеш-функции нужны для контроля целостности информации и создания подписи. Если в данных изменится хотя бы один байт, хеш-функция выдаст другой результат.

Хеши бывают криптографические и некриптографические. Некриптографические хеш-функции возвращают слишком короткую последовательность байт. Например, CRC32 и CRC64 возвращают 32- и 64-битные целые числа, что соответствует 4 и 8 байтам. Из-за этого часто возникают коллизии.

***Коллизия*** — это получение одинакового результата хеш-функции при разных входящих данных.

В Go есть общий для всех хеш-функций интерфейс — **hash.Hash.** 

**Xеш-функция SHA256**. Реализация этой хеш-функции — в пакете **crypto/sha256.**

**Пример использование**
```Go
package main

import (
    "crypto/sha256"
    "fmt"
)

func main() {
    src := []byte("Здесь могло быть написано, чем Go лучше Rust. " + "Но после хеширования уже не прочитаешь.")

    h := sha256.New()
    h.Write(src)
    dst := h.Sum(nil)

    fmt.Printf("%x", dst)
}
```
Если у вас есть байтовый слайс, то посчитать хеш **SHA256** можно вызовом одной функции: Sum256(data []byte). Она возвращает массив из 32 байт. Это длина получаемого хеша. 

Ещё одна популярная хеш-функция — **MD5** (пакет crypto/md5). Она работает очень быстро. Длина хеша — 16 байт. Хотя MD5 не рекомендуют использовать из-за низкой криптостойкости, её всё ещё применяют для подсчёта контрольных сумм файлов и хеширования некритичной информации.


**Пример**

Допишите программу, которая считает хеш MD5 случайной последовательности 512 байт. Один подсчёт сделайте с использованием интерфейса hash.Hash, а другой — функцией md5.Sum([]byte).

```Go
package main

import (
    "bytes"
    "crypto/md5"
    "crypto/rand"
    "fmt"
)

func main() {
    var (
        data  []byte         // слайс случайных байт
        hash1 []byte         // хеш с использованием интерфейса hash.Hash
        hash2 [md5.Size]byte // хеш, возвращаемый функцией md5.Sum
    )
    // допишите код
    // 1) генерация data длиной 512 байт
    // 2) вычисление hash1 с использованием md5.New
    // 3) вычисление hash2 функцией md5.Sum

    // ...

    // hash2[:] приводит массив байт к слайсу
    if bytes.Equal(hash1, hash2[:]) {
        fmt.Println("Всё правильно! Хеши равны")
    } else {
        fmt.Println("Что-то пошло не так")
    }
} 
```
**Решение**

```Go
    data = make([]byte, 512)
    _, err := rand.Read(data)
    if err != nil {
        panic(err)
    }

    h := md5.New()
    h.Write(data)
    hash1 = h.Sum(nil)

    hash2 = md5.Sum(data)
```

# Подпись данных

Чтобы подписать данные, создаётся последовательность байт, которая позволяет проверять целостность этих данных и автора подписи. При больших объёмах данных лучше вычислять и подписывать их хеш.

Рассмотрим подписывание данных с использованием ключа. Предположим, сервер выдаёт новым пользователям токены и пишет их в куки. При повторном обращении юзера сервер читает куки и идентифицирует пользователя. Как защититься от генерации и использования токенов третьими лицами? Одно из решений — подписывать и проверять токены секретным ключом, который хранится на сервере.

Создадим подпись данных с помощью алгоритма HMAC. В отличие от обычных хеш-функций, для функции **hmac.New** .  **hash.Hash** нужно указать используемую криптографическую хеш-функцию и ключ.


```Go
package main

import (
    "crypto/hmac"
    "crypto/rand"
    "crypto/sha256"
    "fmt"
)

func generateRandom(size int) ([]byte, error) {
    // генерируем случайную последовательность байт
    b := make([]byte, size)
    _, err := rand.Read(b)
    if err != nil {
        return nil, err
    }

    return b, nil
}

func main() {
    // подписываемое сообщение
    src := []byte("Видишь гофера? Нет. И я нет. А он есть.")

    // создаём случайный ключ
    key, err := generateRandom(16)
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    // подписываем алгоритмом HMAC, используя SHA256
    h := hmac.New(sha256.New, key)
    h.Write(src)
    dst := h.Sum(nil)

    fmt.Printf("%x", dst)
}
```

В данном случае невозможно проверить исходную строку и полученную подпись, так как случайный ключ исчез после завершения программы.  Чтобы проверить подлинность подписи, нужно сделать две операции:
+ Заново пересчитать подпись с тем же ключом.
+ Функцией hmac.Equal проверить, что подписи совпадают.


**Задание**

Есть сообщение в 16-битном формате, состоящее из идентификатора uint32 и подписи. Проверьте подпись алгоритмом HMAC, используя хеш-функцию SHA256 и секретный ключ. Выведите значение идентификатора.


```Go
package main

import (
    "crypto/hmac"
    "crypto/sha256"
    "encoding/binary"
    "encoding/hex"
    "fmt"
)

var secretkey = []byte("secret key")

func main() {
    var (
        data []byte // декодированное сообщение с подписью
        id   uint32 // значение идентификатора
        err  error
        sign []byte // HMAC-подпись от идентификатора
    )
    msg := "048ff4ea240a9fdeac8f1422733e9f3b8b0291c969652225e25c5f0f9f8da654139c9e21"

    // допишите код
    // 1) декодируйте msg в data
    // 2) получите идентификатор из первых четырёх байт,
    //    используйте функцию binary.BigEndian.Uint32
    // 3) вычислите HMAC-подпись sign для этих четырёх байт

    // решение
    data, err = hex.DecodeString(msg)
    if err != nil {
        panic(err)
    }
    id = binary.BigEndian.Uint32(data[:4])
    h := hmac.New(sha256.New, secretkey)
    h.Write(data[:4])
    sign = h.Sum(nil) 


    if hmac.Equal(sign, data[4:]) {
        fmt.Println("Подпись подлинная. ID:", id)
    } else {
        fmt.Println("Подпись неверна. Где-то ошибка")
    }
}
```


# Шифрование
Алгоритмы шифрования делятся на:
+ симметричные и 
+ асимметричные. 

Симметричные требуют для шифрования и расшифровки один и тот же ключ, асимметричные работают с парой ключей.

Рассмотрим только симметричные алгоритмы. Базовый интерфейс симметричного шифрования — **cipher.Block** из пакета **crypto/cipher.**

Зашифруем и расшифруем текст с помощью алгоритма AES. Это блочный алгоритм, размер блока — 16 байт. Для работы алгоритма нужно сгенерировать ключ из 16, 24 или 32 байт. В зависимости от размера ключа будет выбрано шифрование AES128, AES192 или AES256. Чем длиннее ключ, тем более криптостойкий получится шифр.


```Go
package main

import (
    "crypto/aes"
    "crypto/rand"
    "fmt"
)

func generateRandom(size int) ([]byte, error) {
    b := make([]byte, size)
    _, err := rand.Read(b)
    if err != nil {
        return nil, err
    }

    return b, nil
}

func main() {
    src := []byte("Ключ от сердца") // данные, которые хотим зашифровать
    fmt.Printf("original: %s\n", src)

    // константа aes.BlockSize определяет размер блока и равна 16 байтам
    key, err := generateRandom(aes.BlockSize) // ключ шифрования
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    // получаем cipher.Block
    aesblock, err := aes.NewCipher(key)
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    dst := make([]byte, aes.BlockSize) // зашифровываем
    aesblock.Encrypt(dst, src)
    fmt.Printf("encrypted: %x\n", dst)

    src2 := make([]byte, aes.BlockSize) // расшифровываем
    aesblock.Decrypt(src2, dst)
    fmt.Printf("decrypted: %s\n", src2)
}
```


Чтобы шифровать данные произвольной длины, нужен алгоритм, который делил бы данные на блоки, преобразовывал и подавал их на вход **AES**. Стоит взять **алгоритм GCM.**

Для работы **алгоритма GCM** нужно дополнительно сгенерировать вектор инициализации из 12 байт. Вектор должен быть уникальным для каждой процедуры шифрования. Если переиспользовать один и тот же вектор, можно атаковать алгоритм, подавая на вход данные с разницей в один байт, и по косвенным признакам вычислить ключ шифрования.

```Go
package main

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "fmt"
)

func generateRandom(size int) ([]byte, error) {
    b := make([]byte, size)
    _, err := rand.Read(b)
    if err != nil {
        return nil, err
    }

    return b, nil
}

func main() {
    src := []byte("Этюд в розовых тонах") // данные, которые хотим зашифровать
    fmt.Printf("original: %s\n", src)

    // будем использовать AES256, создав ключ длиной 32 байта
    key, err := generateRandom(2 * aes.BlockSize) // ключ шифрования
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    aesblock, err := aes.NewCipher(key)
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    aesgcm, err := cipher.NewGCM(aesblock)
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    // создаём вектор инициализации
    nonce, err := generateRandom(aesgcm.NonceSize())
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    dst := aesgcm.Seal(nil, nonce, src, nil) // зашифровываем
    fmt.Printf("encrypted: %x\n", dst)

    src2, err := aesgcm.Open(nil, nonce, dst, nil) // расшифровываем
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }
    fmt.Printf("decrypted: %s\n", src2)
}
```

**Задание 4**

Есть зашифрованное сообщение и пароль. Расшифруйте текст, если известно, что:
сообщение зашифровано алгоритмами GCM и AES256;
ключ шифрования получен из пароля хеш-функцией SHA256;
для вектора инициализации используются последние байты ключа.

```Go
package main

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/sha256"
    "encoding/hex"
    "fmt"
)

const (
    password = "x35k9f"
    msg      = `0ba7cd8c624345451df4710b81d1a349ce401e61bc7eb704ca` +
        `a84a8cde9f9959699f75d0d1075d676f1fe2eb475cf81f62ef` +
        `f701fee6a433cfd289d231440cf549e40b6c13d8843197a95f` +
        `8639911b7ed39a3aec4dfa9d286095c705e1a825b10a9104c6` +
        `be55d1079e6c6167118ac91318fe`
)

func main() {
	// допишите код
	// 1) получите ключ из password, используя sha256.Sum256
	key := sha256.Sum256([]byte(password))

	// 2) создайте aesblock и aesgcm
	aesblock, err := aes.NewCipher(key[:])
	if err != nil {
		panic(err)
	}

	// 3) получите вектор инициализации aesgcm.NonceSize() байт с конца ключа
	aesgcm, err := cipher.NewGCM(aesblock)
	if err != nil {
		panic(err)
	}

	// 4) декодируйте сообщение msg в двоичный формат
	// создаём вектор инициализации
	nonce := key[len(key)-aesgcm.NonceSize():]

	encrypted, err := hex.DecodeString(msg)
	if err != nil {
		panic(err)
	}

	// 5) расшифруйте и выведите данные

	// расшифровываем
	decrypted, err := aesgcm.Open(nil, nonce, encrypted, nil)
	if err != nil {
		panic(err)
	}

	fmt.Println(string(decrypted))
}
```
**Дополнительные материалы**

Cryptanalytic Attacks on Pseudorandom Number Generators.
Алгоритм AES.
Алгоритм GCM.
Алгоритм HMAC.