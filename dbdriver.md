# Обобщённый подход и драйверы
Для работы с SQL в Go есть пакет **database/sql.** Чтобы получить доступ к базе данных, используется структура **sql.DB.**


> ***Важно:*** 
>
> + **sql.DB** — это **интерфейс** к драйверу базы данных.
> + **Драйвер** — реализация интерфейса, который содержит логику работы с конкретной СУБД. 
>
> Драйвер спроектирован так, что в коде не нужно вручную работать с базой — можно пользоваться только методами sql.DB. Код не зависит от драйвера, и его легко сменить.
>  


Структура **sql.DB** управляет пулом соединений. Можно сконфигурировать разные политики: либо установить фиксированное количество соединений, либо настроить динамическое открытие новых соединений (при повышенной нагрузке) и закрытие неиспользуемых соединений по тайм-ауту.

С помощью драйвера можно работать со многими БД, например: 
SQLite, MySQL, MS SQL, PostgreSQL, Apache Avatica, Oracle, ClickHouse.

## Импорт драйвера
Будем использовать **sqlite3** — это простая, не требующая дополнительных зависимостей и одновременно функциональная БД. Её легко установить на большинстве операционных систем. В неё легко импортировать csv-файл.

Особенность пакета **database/sql** в том, что он написан обобщённо, все привязки к движку вынесены в драйвер. Вы можете выбрать любую реляционную базу данных и разбирать примеры в ней. 

В следующих уроках и для выполнения инкремента будем использовать **PostgreSQL**. 

Движок **Postgre** мощнее, в нём больше дополнительных возможностей. Go-код и SQL-декларации будут продолжать работать (за исключением специфических особенностей движка и драйвера, документированных в пакетах драйверов).

### sqlite3

Сначала установим драйвер. Можно выбрать любой, например один из самых популярных: github.com/mattn/go-sqlite3.

```bash
go get github.com/mattn/go-sqlite3
```

Затем импортируем интерфейс **sql.DB** и драйвер go-sqlite3 в проект:

```Go
import (
    "database/sql"
    _ "github.com/mattn/go-sqlite3"
) 
```

>Обратите внимание: пакет **go-sqlite3** импортирован анонимно. Не получится обращаться напрямую к go-sqlite3. Внутри пакет зарегистрирует себя самостоятельно и будет доступен для использования через **sql.DB**.


> **Вопрос**: Если нас не интересует пространство имён драйвера github.com/mattn/go-sqlite3, зачем вообще его импортировать? Что происходит при этом импорте?
**Ответ**:Отрабатывают init()-функции пакета драйвера.


Всё готово для работы. Получили ресурс — доступ к базе данных. Используем конструкцию отложенного исполнения **defer**, чтобы закрыть соединение и освободить ресурс.

```go
func main() {
    db, err := sql.Open("sqlite3", "db.db")
    if err != nil {
        panic(err)
    }
    defer db.Close()

    // работаем с базой
    // ...
    // можем продиагностировать соединение

    ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
    defer cancel()
    if err = db.PingContext(ctx); err != nil {
        panic(err)
    }
    // в процессе работы
}
```

+ С помощью функции **Open** открываем соединение с базой данных. Первым аргументом указываем 
1.  **драйвер** (MySQL, SQLite, PostgreSQL и др.). 
2.  **Второй аргумент — это строка для драйвера**, она определяется самим драйвером. В нашем случае второй аргумент — путь до файла базы данных.

С помощью **defer db.Close()** закрываем соединение с базой, после того как функция закончит выполнение. Не нужно открывать и закрывать соединение в каждой функции.** Open/Close** разработаны таким образом, чтобы работать постоянно и долго, а не краткосрочно.


На самом деле соединение будет установлено только тогда, когда выполнится первый запрос к базе данных. Проверить соединение можно методом **DB.PingContext()** — он контролирует состояние и обновляет в случае необходимости. Метод принимает контекст и возвращает ошибку, если соединение утеряно и восстановить его невозможно.