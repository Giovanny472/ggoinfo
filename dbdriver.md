# Обобщённый подход и драйверы
Для работы с SQL в Go есть пакет **database/sql.** Чтобы получить доступ к базе данных, используется структура **sql.DB.**


> ***Важно:*** 
>
> + **sql.DB** — это **интерфейс** к драйверу базы данных.
> + **Драйвер** — реализация интерфейса, который содержит логику работы с конкретной СУБД. 
>
> Драйвер спроектирован так, что в коде не нужно вручную работать с базой — можно пользоваться только методами sql.DB. Код не зависит от драйвера, и его легко сменить.
>  


Структура **sql.DB** управляет пулом соединений. Можно сконфигурировать разные политики: либо установить фиксированное количество соединений, либо настроить динамическое открытие новых соединений (при повышенной нагрузке) и закрытие неиспользуемых соединений по тайм-ауту.

С помощью драйвера можно работать со многими БД, например: 
SQLite, MySQL, MS SQL, PostgreSQL, Apache Avatica, Oracle, ClickHouse.

## Импорт драйвера
Будем использовать **sqlite3** — это простая, не требующая дополнительных зависимостей и одновременно функциональная БД. Её легко установить на большинстве операционных систем. В неё легко импортировать csv-файл.

Особенность пакета **database/sql** в том, что он написан обобщённо, все привязки к движку вынесены в драйвер. Вы можете выбрать любую реляционную базу данных и разбирать примеры в ней. 

В следующих уроках и для выполнения инкремента будем использовать **PostgreSQL**. 

Движок **Postgre** мощнее, в нём больше дополнительных возможностей. Go-код и SQL-декларации будут продолжать работать (за исключением специфических особенностей движка и драйвера, документированных в пакетах драйверов).

### sqlite3

Сначала установим драйвер. Можно выбрать любой, например один из самых популярных: github.com/mattn/go-sqlite3.

```bash
go get github.com/mattn/go-sqlite3
```

Затем импортируем интерфейс **sql.DB** и драйвер go-sqlite3 в проект:

```Go
import (
    "database/sql"
    _ "github.com/mattn/go-sqlite3"
) 
```

>Обратите внимание: пакет **go-sqlite3** импортирован анонимно. Не получится обращаться напрямую к go-sqlite3. Внутри пакет зарегистрирует себя самостоятельно и будет доступен для использования через **sql.DB**.


> **Вопрос**: Если нас не интересует пространство имён драйвера github.com/mattn/go-sqlite3, зачем вообще его импортировать? Что происходит при этом импорте?
**Ответ**:Отрабатывают init()-функции пакета драйвера.


Всё готово для работы. Получили ресурс — доступ к базе данных. Используем конструкцию отложенного исполнения **defer**, чтобы закрыть соединение и освободить ресурс.

```go
func main() {
    db, err := sql.Open("sqlite3", "db.db")
    if err != nil {
        panic(err)
    }
    defer db.Close()

    // работаем с базой
    // ...
    // можем продиагностировать соединение

    ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
    defer cancel()
    if err = db.PingContext(ctx); err != nil {
        panic(err)
    }
    // в процессе работы
}
```

+ С помощью функции **Open** открываем соединение с базой данных. Первым аргументом указываем 
1.  **драйвер** (MySQL, SQLite, PostgreSQL и др.). 
2.  **Второй аргумент — это строка для драйвера**, она определяется самим драйвером. В нашем случае второй аргумент — путь до файла базы данных.

С помощью **defer db.Close()** закрываем соединение с базой, после того как функция закончит выполнение. Не нужно открывать и закрывать соединение в каждой функции.** Open/Close** разработаны таким образом, чтобы работать постоянно и долго, а не краткосрочно.


На самом деле соединение будет установлено только тогда, когда выполнится первый запрос к базе данных. Проверить соединение можно методом **DB.PingContext()** — он контролирует состояние и обновляет в случае необходимости. Метод принимает контекст и возвращает ошибку, если соединение утеряно и восстановить его невозможно.

```
func (db *DB) PingContext(ctx context.Context) error 
```

>Некоторые драйверы требуют cgo («си-гоу»), а некоторые нет. Если режим cgo включён, можно напрямую исполнять C-код, а результат использовать в Go-коде.


##Основные драйверы

Если открыть список доступных драйверов(https://github.com/golang/go/wiki/SQLDrivers), можно насчитать более пятидесяти. И для каждой из основных баз данных —  SQLite, MySQL (включая MariaDB, Google Cloud SQL и другие), PostgreSQL — есть минимум два или три популярных.

>**Важно** понимать, что через какое-то время может выйти новый драйвер, который будет поддерживать больше возможностей и будет ещё быстрее. При написании проекта обязательно смотрите полный список доступных драйверов.

#### Driver для sqlite
SQLite	https://pkg.go.dev/modernc.org/sqlite	Не требует CGO. Написан на чистом Go.

#### Подготовка базы данных
В следующих уроках вы научитесь получать данные из таблицы, применять SQL-выражения (стейтменты) и транзакции. Чтобы наглядно показать разницу в работе со стейтментами и без них, подготовим базу данных. Использовать будем SQLite.
Для работы возьмём готовый набор данных о популярных в США видеороликах на YouTube. Скачайте csv-файл здесь(https://code.s3.yandex.net/go/USvideos.csv  ).

Посмотрите, из чего состоит файл. Так как он большой, удобно пользоваться стандартными консольными утилитами head и tail. Команда head покажет, что находится в начале файла, а tail — что в конце.

```
head USvideos.csv 
```


## Запросы к базе данных

Запросы можно выполнять двумя функциями:

1. **QueryContext()**, когда сервер возвращает записи — например, когда отправляем SQL-запрос SELECT;
2. **ExecContext()**, когда сервер SQL ничего не возвращает — например, когда пишем INSERT.

Посчитаем количество всех записей в базе данных:

```go
// в прошлом уроке вы уже видели, как открыть соединение с базой
db, err := sql.Open("sqlite3", "db.db")
if err != nil {
    panic(err)
}
defer db.Close()

// готовим контейнер
var id int64

// делаем запрос
row := db.QueryRowContext(ctx, "SELECT COUNT(*) as count FROM videos")

// разбираем результат
err := row.Scan(&id)
if err != nil {
    log.Fatal(err)
}

fmt.Println(id)

```

Итак, порядок действий:
1. Выполняем запрос к базе данных. Так как результатом всегда будет одна запись, можно использовать метод **QueryRowContext()** вместо **QueryContext()**.
2. Вызываем метод **Scan()**, который ассоциирует результат с переменной. В случае нескольких значений указываем их последовательно — так же, как выводим в SQL.
3. В случае ошибки — выводим сообщение об ошибке.

Многие методы пакета database/sql принимают первым аргументом **ctx context.Context**:

```go
func (db *DB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *Row
```

!!!> Контекст позволяет ограничить по времени или прервать слишком долгие или уже не нужные операции с базой данных, назначить для них дедлайн или тайм-аут. Вот пример использования контекста:
```go
// конструируем контекст с 5-секундным тайм-аутом
// после 5 секунд затянувшаяся операция с БД будет прервана
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)

// не забываем освободить ресурс
defer cancel()

// обращаемся к БД
row := db.QueryRowContext(ctx, "SELECT COUNT(*) as count FROM videos") 
```

!!!> Go — язык преимущественно бэкенд-разработки. Поэтому запросы к БД вы скорее всего будете делать из обработчиков (http.Handler) ваших серверов. В таких случаях стоит наследовать контекст HTTP-запроса:

```go
func MyHandler(w http.ResponseWriter, r *http.Request) {
  
    // наследуем контекcт запроса r *http.Request,
    // оснащая его Timeout
    ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
    
    // не забываем освободить ресурс
    defer cancel()
    
    // делаем обращение к db в рамках полученного контекста
    rows, err := db.QueryContext(ctx, "SELECT something")
    
    // отрабатываем запрос
    // ...
} 
```

!!!> Важно: методы Query() или Exec() (без Context) под капотом используют context.Background. Контекст в операциях с БД присутствует всегда. Если вы пользуетесь инструментарием context.Context, нужно применять методы QueryContext() и ExecContext(), позволяющие установить контекст явно.

**Задание 1 из 6** Как передаётся SQL-инструкция методу QueryContext()?
**Правильный ответ** . Обычным SQL-синтаксисом в виде строки string.
Да. Строковый аргумент query принимает инструкцию обычным SQL-синтаксисом.


## Как работает Scan
Когда вызывается метод **Scan()**, пакет **database/sql** автоматически преобразует значения в тот тип переменных, который был передан.

Представьте, что есть атрибут **is_disabled** и это строковое поле **VARCHAR(10)** или TEXT — со значениями **true, T, TRUE, 1 или 0, false, F**. 

Если передадим ссылку на строку, после этого нужно будет вызвать метод **ParseBool()**, чтобы сделать преобразование или вернуть ошибки. И так для каждой переменной.

Если же сразу передадим ссылку на переменную типа bool, пакет database/sql сам сделает преобразования и вернёт переменную (или ошибку в случае невозможности). Код станет чище и компактнее.