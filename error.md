# errors, log

Так как Go позволяет возвращать из функций несколько значений, принято последним значением возвращать ошибку. Если возвращаемое значение ошибки равно nil, функция завершилась корректно. В противном случае нужно обработать ошибку и/или вернуть её выше по стеку. Если функция завершилась с ошибкой, не стоит использовать остальные возвращаемые значения: они могут быть не определены, функция может выполниться не полностью и не успеть вычислить их значения.

Тип error
Ошибкой в языке Go может быть значение любого типа, который совместим с интерфейсным типом error.

```go
type error interface {
    Error() string
} 
```
Для создания ошибки чаще всего применяют:

aункцию ( в которой указывают шаблон форматирования и дополнительные параметры.)
```go
fmt.Errorf(format string, a ...interface{})
```
или функцию 
```go
errors.New(text string)
```
**пример:**
```go
if userID <= 0 {
    return errors.New(`invalid userID`)
} else if !User(userID) {
    return fmt.Errorf(`can't find user id (%d)`, userID)
}
```

По умолчанию ошибки имеют тип, который может хранить только строку. Можно создать свой тип с необходимыми полями, определить для него метод Error() string и возвращать ошибки с дополнительной информацией. 

Например, для сохранения времени возникновения ошибки можно определить такой тип:

```go
// TimeError предназначен для ошибок с фиксацией времени возникновения.
type TimeError struct {
    Time time.Time
    Err  error
}

// Error добавляет поддержку интерфейса error для типа TimeError.
func (te *TimeError) Error() string {
    return fmt.Sprintf("%v %v", te.Time.Format(`2006/01/02 15:04:05`), te.Err)
}

// NewTimeError упаковывает ошибку err в тип TimeError c текущим временем.
func NewTimeError(err error) error {
    return &TimeError{
        Time: time.Now(),
        Err:  err,
    }
}
```

>При создании ошибок всегда нужно возвращать указатели на структуру. Тогда, если создать ошибки с одинаковыми данными, они не будут равны друг другу. Например, если создать ошибку errors.New("EOF"), она не будет равна io.EOF, которая определяется точно так же. Если вместо указателя возвращать структуру, то нельзя будет однозначно идентифицировать ошибку.


