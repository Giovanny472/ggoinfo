# database/sql

Чтобы узнать, что чаще всего гуглят разработчики про Go и SQL, достаточно взглянуть на список самых популярных вопросов на Stack Overflow:

+ Что означает символ _ перед импортом пакета для работы с базой данных?
+ Как рекомендуется подключаться к базе данных в Go?
+ Транзакции в SQL — как определить, Commit или Rollback?
+ Как сконвертировать запись из базы данных в структуру на Go?

## Пакет gomock. Имитация данных для тестирования

Хорошая практика — тестировать написанный код. Для этого стандартная библиотека предлагает пакет testing. Пакет предназначен для юнит-тестирования и прекрасно справляется со своими задачами. Сложности возникают, когда тестируемый код активно работает с базами данных и сетевыми соединениями. А код на Go, серверном языке, по большей части именно такой и есть. 

Чтобы протестировать код, работающий с БД, нужно обеспечить окружение, включающее эту базу данных. И обеспечить нужно в песочнице, а не в производственной среде, чтобы не поломать производственные процессы. Получится уже не юнит-, а интеграционное тестирование. 

Иногда для упрощения юнит-тестирования применяют заглушки, **моки — mocks**.

Сервис описывают интерфейсом, а в тестовой среде подменяют сервис заглушкой, которая реализует интерфейс, но не выполняет фактических вычислений. Это распространённый приём в тестировании. Только писать заглушки — занятие хоть и рутинное, но трудоёмкое. 

Для экономии времени используют пакеты, автоматизирующие создание **mocks** путём генерации кода заглушек из объявленных интерфейсов. Наиболее популярны пакеты, зарекомендовавшие себя на практике, — это testify и gomock, они похожи по функционалу.

**gomock** 
```Git
go install github.com/golang/mock/mockgen)
```
Получаем исполняемую команду **mockgen**, которая и делает кодогенерацию. **mockgen** может работать в двух основных режимах:
1. Генерация из исходного кода с использованием AST. Включается флагом **-source**.
```Git
mockgen -source=src_file.go 
```
2. Генерация интроспекцией. Код сначала компилируется, потом разбирается при помощи пакета reflect. Для запуска в этом режиме не нужно устанавливать специальные флаги, а нужно предоставить два позиционных аргумента: путь тестируемого пакета (такой же, как в инструкции import) и список разделённых запятой символов, для которых требуется сгенерировать заглушки.
```git
mockgen database/sql/driver Conn,Driver
```

**mockgen** распознаёт и другие флаги, детализирующие поведение утилиты. Описание можно открыть на сайте разработчика или вызвать командой mockgen **-help.**

**gomock** в деле: Вот хранилище, описанное интерфейсом:

```go
// файл store/store.go
package store

type Store interface {
   Set(key string, value []byte) error
   Get(key string) ([]byte, error)
   Delete(key string) error
}
```
А вот использующая его функция, которую нужно протестироватъ:
```go
// файл persistent/persistent.go
func Lookup(s Store, c Cond) []byte {
  ...
} 
```

Для начала построим удобную файловую иерархию:

```
project
|___ store
|    |___ store.go
|
|___ mocks
|    |___ mock_store.go
|
|___ persistent
     |___ persistent.go
     |___ persistent_test.go
```

+ Папку mocks для gomock нужно создать вручную. 
+ Файл mock_store.go создавать не нужно, его создаст **mockgen**.

```
mockgen -destination=mocks/mock_store.go -package=mocks store Store
```
Здесь:
+ Флаг **-destination** указывает имя файла, куда нужно записать сгенерированный код. Если этот флаг не указать, результаты будут просто выведены в консоль.
+ **-package** — путь пакета сгенерированных заглушек, по умолчанию будет mock_store.
+ **store** — имя пакета, для интерфейсов которого делаем заглушки.
+ **Store** — имя целевого интерфейса.

В результате в файле **mocks/mock_store.go** должен оказаться примерно такой код:

```Go
// Code generated by MockGen. DO NOT EDIT.
// Source: ./store/store.go

// Package mock is a generated GoMock package.
package mock

import (
   gomock "github.com/golang/mock/gomock"
   reflect "reflect"
)

// MockStore is a mock of Store interface
type MockStore struct {
   ctrl     *gomock.Controller
   recorder *MockRepositoryMockRecorder
}

// NewMockStore creates a new mock instance
func NewMockStore(ctrl *gomock.Controller) *MockStore {
   mock := &MockStore{ctrl: ctrl}
   mock.recorder = &MockStoreMockRecorder{mock}
   return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockStore) EXPECT() *MockStoreMockRecorder {
   return m.recorder
}

// Get mocks base method
func (m *MockStore) Get(key string) ([]byte, error) {
   ret := m.ctrl.Call(m, "Get", key)
   ret0, _ := ret[0].([]byte)
   ret1, _ := ret[1].(error)
   return ret0, ret1
}

// Get indicates an expected call of Get
func (mr *MockStoreMockRecorder) Get(key interface{}) *gomock.Call {
   return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockStore)(nil).Get), key)
}
...
```

В файле появилась декларация заглушки MockStore и её методов и декларация типа MockStoreMockRecorder, используемого для стабов. Инстанцировать MockStoreMockRecorder можно методом MockStore.EXPECT().
**Теперь можно писать тесты: (persistent_test.go)**

```Go
// файл persistent/persistent_test.go
package persistent

import (
    "project/mocks"
    "project/store"
    "testing"
)

func TestGet(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()

    s := mocks.NewMockStore(ctrl)

    // гарантируем, что заглушка
    // при вызове с аргументом "Key" вернёт "Value"
    s.EXPECT().Get("Key").Return([]byte("Value"))
    
    // тестируем функцию
    Lookup(s, someCond)
}
```
Попробуем стабы:

```Go
func TestGet(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()

    s := mocks.NewMockStore(ctrl)

    value := []byte("Some value")

    // при вызове с произвольным аргументом
    // заглушка будет возвращать слайс 
    // метод может быть вызван не более 5 раз
    s.EXPECT().
    Get(gomock.Any()).
    Return(value, nil).
    MaxTimes(5)
    
    // тестируем функцию
    Lookup(s, someCond)
}
```

Перечислим **преимущества** пакета **gomock**:
+ делает тестирование проще и удобнее;
+ хорошо работает с пакетом testing стандартной библиотеки;
+ генерирует заглушки для сторонних сервисов, избавляя от необходимости писать рутинный код вручную;
+ позволяет точно характеризовать поведение этих заглушек.




