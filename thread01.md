# Многопоточность
узнаем:
+ как устроена многопоточность в Go;
+ как писать многопоточный код;
+ как использовать паттерны многопоточного кода.


темы:
+ как устроена многопоточность в Go;
+ как определяются и вызываются горутины;
+ какие примитивы синхронизации есть в стандартной библиотеке;
+ что такое каналы и как с ними работать;
+ зачем нужны атомарные операции и как их использовать;
+ какие паттерны многопоточного кода применяются в Go.


# Основы многопоточности
Как вы уже знаете, основная фишка языка Go — готовые решения и инструменты для написания многопоточного кода.
Напомним, что в Go реализована модель CSP (Communicating Sequential Processes). Программа представляет собой множество одновременно работающих подзадач, которые общаются друг с другом с помощью каналов связи. Модель CSP реализована абстракциями goroutine и channel.

## Многопоточность и асинхронный ввод-вывод

Как можно реализовать многозадачность? Нужны два механизма в операционной системе:
+ многопоточность;
+ асинхронный ввод-вывод.

Для начала разберёмся с многопоточностью.

Представьте себе два мира — процессы операционной системы и ядра процессора.

**Процесс** — это выполняющаяся программа и её ресурсы: регистры, stack-память, heap-память, дескрипторы и т. д. Сам процесс хотя и хранит исполняемый код, но не может его выполнить. За выполнение кода отвечают потоки.

**Поток выполнения** — это часть процесса. В одном процессе может быть несколько потоков. Каждый поток имеет доступ к контексту родительского процесса и кроме этого содержит собственные ресурсы: стек, регистры, специфические данные потока. Планировщик операционной системы распределяет потоки по ядрам процессора, чтобы дать каждому потоку равное время выполнения.

Когда планировщик переключает ядро с выполнения одного потока на другой, контекст предыдущего потока выгружается из памяти и загружаются данные потока, который будет выполняться. Если потоков слишком много, то на переключение между ними уходит много времени: из-за постоянных операций выгрузки-загрузки контекста программа выполняется дольше.


Поэтому некоторые современные языки программирования реализуют лёгкие потоки (green threads). Такие потоки легче, потому что легче их контекст, они могут занимать меньший объём stack-памяти и использовать не все регистры. За планирование работы лёгких потоков отвечает среда выполнения языка, именуемая рантайм (runtime). Благодаря оптимизациям языка, переключение между лёгкими потоками происходит быстрее, чем переключение между потоками операционной системы.

В Go лёгкие потоки называются горутинами (**goroutines**).

## асинхронный ввод-вывод:

В Go поддержан асинхронный ввод-вывод — он реализован через горутины. Когда из кода делается сетевой запрос, рантайм языка уводит горутину в очередь — и возвращает её тогда, когда готов результат. Благодаря тому что получается быстро переключать горутины, время процессора используется эффективно.

## Проблемы многопоточности

Проблемы с многопоточностью возникают, когда несколько потоков обращаются к одной и той же памяти внутри процесса.

Самая частая проблема — **состояние гонки (race condition).**

Все арифметические и логические действия в коде — это неатомарные операции. Если несколько потоков одновременно запустятся на разных ядрах процессора и начнут записывать данные в одну и ту же область памяти, возникнет конкуренция потоков: один поток скопирует в свой регистр устаревшую копию данных, другой поток перезапишет данные и поменяет на свою версию и т. д.


Но есть способы предотвратить состояние гонки. Вот некоторые из них:

+ **Мьютексы** (mutex — от mutual exclusion). Мьютекс — это ресурс, который может быть занят только одним потоком. Для других потоков мьютекс заблокируется — они будут ждать, пока он освободится, чтобы продолжить работу.

+ **Атомарные операции**. В современных процессорах запрограммированы команды, которые позволяют производить некоторые арифметические и логические действия атомарно. Используя атомарные операции, можно, к примеру, увеличивать целочисленный счётчик из нескольких потоков одновременно без дополнительных блокировок.

+ **Обмен сообщениями**. Даёт потокам возможность обмениваться сообщениями или сигналами. Идея обмена сообщениями в том, чтобы создать очередь, в которую один поток может скопировать данные и из которой другой поток может прочитать свою копию.

В Go используются все три способа. Но самый предпочтительный — обмен сообщениями через каналы. Благодаря им можно написать более простой и надёжный многопоточный код. Почему более надёжный? Каналы позволяют минимизировать вероятность ошибки программиста.

## Вот самые частые ошибки
**Взаимная блокировка (deadlock)**. Представьте, что человек покупает в буфете кофе, но у продавщицы нет сдачи с пятитысячной купюры. Буфетчица просит купюры помельче, а покупатель — сдачу. Если в коде используются несколько мьютексов или каналов, то может возникнуть ситуация, когда все потоки ожидают сигналов один от другого и не могут продолжить работу.

**Живая блокировка (livelock)**. Представьте, что вы договорились созвониться с человеком в определённое время. Каждый раз, когда вы набираете его номер, он звонит вам. Вы отменяете вызов и ждёте какое-то время, но он делает то же самое. Livelock — это cостояние программы, при котором потоки что-то делают, но не выполняют полезной работы. Например, два потока пытаются взять несколько мьютексов. Один берёт А и B, а другой B и A. Если второй мьютекс занят, каждый поток откатывается назад. Оба потока формально не будут заблокированы, но они будут постоянно то блокировать, то разблокировать мьютексы.

**Голодание (starvation)**. Представьте, что человек едет с вокзала в аэропорт. Вместе с билетом на самолёт он взял priority pass, прошёл вне очереди, но его не пускают — из-за большой сумки в ручной клади. Он ругается, занимает время стюардесс, а все остальные ждут. В коде такая ситуация возникает, когда горутина захватывает мьютекс на большее время, чем ей нужно на самом деле. Из-за этого другим потокам приходится ждать разблокировки мьютекса.






