# Hash, Crypto

## Хеширование и шифрование

**Генератор псевдослучайных чисел** — генерирует случайные байты на основе стартового числа (seed) и математического алгоритма. Зная число seed, можно повторить последовательность следующих байт.

Он не **подходит** для генерации чувствительных данных, например кук, токенов или ключей.

**Криптостойкий генератор случайных чисел** — генерирует байты на основе энтропии, порождаемой аппаратно. Такую случайность нельзя предугадать, поэтому нельзя вывести всю последовательность. Этот генератор реализован на уровне операционной системы.

В Go сгенерировать криптостойкие случайные байты можно функцией **rand.Read** из пакета **crypto/rand**. В параметре нужно передать:
+ слайс байт ненулевой длины, который будет заполнен случайными байтами. 
+ Размер слайса не изменяется. 
  
Чтобы затем использовать полученный массив байт, например для кук(cookies), нужно дополнительно его закодировать. Это можно сделать функцией ***hex.EncodeToString** из пакета **encoding/hex**.

В отличие от генератора псевдослучайных чисел, этот код будет каждый раз при запуске выводить новую последовательность байт.
```Go
package main

import (
    "crypto/rand"
    "encoding/hex"
    "fmt"
)

func main() {
    // определяем слайс нужной длины
    b := make([]byte, 16)
    // записываем байты в массив b
    _, err := rand.Read(b) 
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    fmt.Println(hex.EncodeToString(b))
} 
```

Пример:  Написать функцию, которая будет генерировать массив случайных байт. Размер массива передаётся параметром. Функция должна возвращать массив в виде строки в кодировке base64.

```Go
func RandBytes(n int) (string, error) {
    b := make([]byte, n)
    _, err := rand.Read(b)
    if err != nil {
        return ``, err
    }
    return base64.StdEncoding.EncodeToString(b), nil
} 
```

## Хеширование 

**Хеш-функция** — это функция, которая приводит любую последовательность байт к установленной длине. Длина зависит от используемого алгоритма. Хеш-функции нужны для контроля целостности информации и создания подписи. Если в данных изменится хотя бы один байт, хеш-функция выдаст другой результат.

Хеши бывают криптографические и некриптографические. Некриптографические хеш-функции возвращают слишком короткую последовательность байт. Например, CRC32 и CRC64 возвращают 32- и 64-битные целые числа, что соответствует 4 и 8 байтам. Из-за этого часто возникают коллизии.

***Коллизия*** — это получение одинакового результата хеш-функции при разных входящих данных.

В Go есть общий для всех хеш-функций интерфейс — **hash.Hash.** 

**Xеш-функция SHA256**. Реализация этой хеш-функции — в пакете **crypto/sha256.**

**Пример использование**
```Go
package main

import (
    "crypto/sha256"
    "fmt"
)

func main() {
    src := []byte("Здесь могло быть написано, чем Go лучше Rust. " + "Но после хеширования уже не прочитаешь.")

    h := sha256.New()
    h.Write(src)
    dst := h.Sum(nil)

    fmt.Printf("%x", dst)
}
```
Если у вас есть байтовый слайс, то посчитать хеш **SHA256** можно вызовом одной функции: Sum256(data []byte). Она возвращает массив из 32 байт. Это длина получаемого хеша. 

Ещё одна популярная хеш-функция — **MD5** (пакет crypto/md5). Она работает очень быстро. Длина хеша — 16 байт. Хотя MD5 не рекомендуют использовать из-за низкой криптостойкости, её всё ещё применяют для подсчёта контрольных сумм файлов и хеширования некритичной информации.


**Пример**

Допишите программу, которая считает хеш MD5 случайной последовательности 512 байт. Один подсчёт сделайте с использованием интерфейса hash.Hash, а другой — функцией md5.Sum([]byte).

```Go
package main

import (
    "bytes"
    "crypto/md5"
    "crypto/rand"
    "fmt"
)

func main() {
    var (
        data  []byte         // слайс случайных байт
        hash1 []byte         // хеш с использованием интерфейса hash.Hash
        hash2 [md5.Size]byte // хеш, возвращаемый функцией md5.Sum
    )
    // допишите код
    // 1) генерация data длиной 512 байт
    // 2) вычисление hash1 с использованием md5.New
    // 3) вычисление hash2 функцией md5.Sum

    // ...

    // hash2[:] приводит массив байт к слайсу
    if bytes.Equal(hash1, hash2[:]) {
        fmt.Println("Всё правильно! Хеши равны")
    } else {
        fmt.Println("Что-то пошло не так")
    }
} 
```
**Решение**

```Go
    data = make([]byte, 512)
    _, err := rand.Read(data)
    if err != nil {
        panic(err)
    }

    h := md5.New()
    h.Write(data)
    hash1 = h.Sum(nil)

    hash2 = md5.Sum(data)
```

# Подпись данных

Чтобы подписать данные, создаётся последовательность байт, которая позволяет проверять целостность этих данных и автора подписи. При больших объёмах данных лучше вычислять и подписывать их хеш.

Рассмотрим подписывание данных с использованием ключа. Предположим, сервер выдаёт новым пользователям токены и пишет их в куки. При повторном обращении юзера сервер читает куки и идентифицирует пользователя. Как защититься от генерации и использования токенов третьими лицами? Одно из решений — подписывать и проверять токены секретным ключом, который хранится на сервере.

Создадим подпись данных с помощью алгоритма HMAC. В отличие от обычных хеш-функций, для функции **hmac.New** .  **hash.Hash** нужно указать используемую криптографическую хеш-функцию и ключ.


```Go
package main

import (
    "crypto/hmac"
    "crypto/rand"
    "crypto/sha256"
    "fmt"
)

func generateRandom(size int) ([]byte, error) {
    // генерируем случайную последовательность байт
    b := make([]byte, size)
    _, err := rand.Read(b)
    if err != nil {
        return nil, err
    }

    return b, nil
}

func main() {
    // подписываемое сообщение
    src := []byte("Видишь гофера? Нет. И я нет. А он есть.")

    // создаём случайный ключ
    key, err := generateRandom(16)
    if err != nil {
        fmt.Printf("error: %v\n", err)
        return
    }

    // подписываем алгоритмом HMAC, используя SHA256
    h := hmac.New(sha256.New, key)
    h.Write(src)
    dst := h.Sum(nil)

    fmt.Printf("%x", dst)
}
```

